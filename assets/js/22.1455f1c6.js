(window.webpackJsonp=window.webpackJsonp||[]).push([[22],{297:function(t,a,r){"use strict";r.r(a);var s=r(10),v=Object(s.a)({},(function(){var t=this,a=t._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"编写高质量代码"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#编写高质量代码"}},[t._v("#")]),t._v(" 编写高质量代码")]),t._v(" "),a("p",[t._v("任何程序员都能写出机器可以阅读的代码，但只有好的程序员才能写出人可以阅读的代码。这句话道出了要写出容易阅读的代码的难度。")]),t._v(" "),a("h2",{attrs:{id:"命名"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#命名"}},[t._v("#")]),t._v(" 命名")]),t._v(" "),a("p",[t._v("我们在程序代码中，往往看到很多类似icount、var、num这样名字变量，还有很多叫作manager、controllor的类，这些都是因为我们想不到应该如何命名导致的。除了名词匮乏，我们的动词往往也很匮乏，证明就是：我们的很多函数名都叫Process()、Run()、Poll()、Loop()诸如此类。如果我们把程序源代码看成是一篇文章，那么这篇文章的词汇，就是各种变量和函数的名字。如果我们在命名上困难重重，那么这篇文章也一定晦涩难懂。")]),t._v(" "),a("p",[t._v("命名上的困难，除了因为我们英语词汇量太小以外，另外一个原因是我们对于业务领域的不了解。在接到需求后，我们往往就急着开始所谓的设计和开发。如果我们把程序仅仅看成一些数据和算法组合，那么我们的命名必然也只是局限于这些数据结构、算法的概念上，比如我们常见到xxMap的结构体，还有xxCallback的函数指针。用这样一堆名字构建起来的程序，就好像摩斯电码一样难以理解。尽管在这些看起来都差不多的字符背后，实现的是一个个鲜活而独特的业务需求，但是光看字面是完全无法想象出来的。这个问题实际上也很好解决，就是我们在写程序之前，多去了解这个程序所在的应用领域，看看这个应用领域里面到底是有些什么样的词汇。")]),t._v(" "),a("p",[t._v("比如一个商业应用中，就会有Bill、Invoice、Deal等专用词汇，在游戏应用中，有Player、NPC、Monster这些概念……我们可以在几乎任何时候，都能从这些业务领域中攫取大量的词汇，来替换掉计算机领域中少得可怜的几个词。如果我们真正把代码中的命名，变成应用领域的词汇，那么这样的代码片段，就是一个描述某种业务领域的文章，如此，可读性就能大大加强。")]),t._v(" "),a("p",[t._v("命名本身并不影响程序的运行，但是我们也没必要直接写出好像被扰码器处理过一样的代码。如果我们的命名词汇既准确又生动，那么我们的代码一定也是非常容易读懂的。特别是，我们阅读代码的目的常常不是要评估代码的算法，而是找到某段业务逻辑的位置来进行修改，一个和业务逻辑有关联的命名，能让我们快速跳过大量不相干的代码，直接定位到需要修改的地方，这对代码维护是非常有利的。")]),t._v(" "),a("p",[t._v("我们知道，面向对象编程，需要以对象类型来对业务代码进行建模，而由于汉语名词的匮乏，我们常常在表达一个对象时，找不到一个专有名词来表达，而是用“做什么什么的东西”来表达这个对象，这对我们代码的设计会造成极大的困扰。因为行为的特征在对象上往往是不够稳定的，一旦我们以行为作对象的名字，而这个对象在后续的迭代中屡次被修改，这样就很容易出现名不符实的情况。")]),t._v(" "),a("p",[t._v("因此我们在设计面向对象代码的时候，不能仅仅以汉语的习惯去设计，而是要多找找有没有专门表达这个对象的英语名词。")]),t._v(" "),a("p",[t._v("如果我们想写出如同自然语言一样易读的软件代码，那么就一定要用自然语言来写文章的结构。但是很可惜的是，自然语言的文章以传情达意为目的，而软件代码主要是控制电脑工作的任务列表。这两者之间一个重要的差异就在于“语句”的存在形式上。")]),t._v(" "),a("h2",{attrs:{id:"封装"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#封装"}},[t._v("#")]),t._v(" 封装")]),t._v(" "),a("p",[t._v("代码是一行行执行的，而电脑对于数据的处理，往往存在很多类似的、重复的处理步骤。此时，就用到了“封装”：我们把类似的、重复的代码封装成子函数；用继承的方法来构建相似的数据对象。如果我们还能用恰如其分的名字来命名这些子函数和子类型，那么我们就能避免长篇累牍的重复代码，从而让代码更容易理解。也许，这种封装是一种“额外”的劳动，因为CPU不管这些，如果你只是想算出结果，那么完全可以用一个函数从头写到尾。但是如果你有意识地做一些有具体业务含义的封装，你会得到另外一个好处就是代码能更方便被重用。代码重用的首要条件是代码可理解，而封装正是对复杂的实现过程进行屏蔽，让人可以快速理解。而业务领域的重复逻辑是非常常见的，如果代码刚好是一些典型的业务流程，那么这些对应流程的代码，就一定能被重用到大量的类似业务流程的处理环节，这样的好处不言而喻。")])])}),[],!1,null,null,null);a.default=v.exports}}]);